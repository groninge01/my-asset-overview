"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cheerio_1 = __importDefault(require("cheerio"));
function product(row, column) {
    const result = [];
    for (let r = 0; r < row; r++) {
        for (let c = 0; c < column; c++) {
            result.push([r, c]);
        }
    }
    return result;
}
function parseValue(element) {
    return cheerio_1.default(element).text();
}
function createTableGrid(rows) {
    let rowSpans = [];
    let colCount = 0;
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = cheerio_1.default("td, th", row).toArray();
        const allColSpans = cells.slice(0, -1).reduce((accumulator, currentValue) => {
            const colSpan = parseInt(cheerio_1.default(currentValue).attr("colspan")) || 1;
            return accumulator + colSpan;
        }, 0) +
            1 +
            rowSpans.length;
        colCount = colCount > allColSpans ? colCount : allColSpans;
        for (let cell of cells) {
            const rowSpan = parseInt(cheerio_1.default(cell).attr("rowspan")) || 1;
            rowSpans.push(rowSpan);
        }
        rowSpans = rowSpans.filter(span => span > 1).map(span => span - 1);
    }
    return Array.from({ length: rows.length }, () => new Array(colCount).fill(null));
}
function parseTable(element, options = {}) {
    const { parser = parseValue } = options;
    const rows = cheerio_1.default("tr", element).toArray();
    const table = createTableGrid(rows);
    let rowSpans = {};
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const row = rows[rowIndex];
        let spanOffset = 0;
        const cells = cheerio_1.default("td, th", row).toArray();
        for (let columnIndex = 0; columnIndex < cells.length; columnIndex++) {
            const cell = cells[columnIndex];
            let col = columnIndex + spanOffset;
            while (rowSpans[col]) {
                spanOffset++;
                col++;
            }
            const rowSpan = parseInt(cheerio_1.default(cell).attr("rowspan")) || 1;
            rowSpans[col] = rowSpan;
            const colSpan = parseInt(cheerio_1.default(cell).attr("colspan")) || 1;
            spanOffset += colSpan - 1;
            const value = parser(cell);
            for (const [dRow, dCol] of product(rowSpan, colSpan)) {
                const cRow = rowIndex + dRow;
                const cCol = col + dCol;
                if (cRow < table.length && cCol < table[dRow].length) {
                    table[cRow][cCol] = value;
                    rowSpans[cCol] = rowSpan;
                }
            }
        }
        rowSpans = Object.entries(rowSpans).reduce((accumulator, [key, value]) => {
            if (value > 1) {
                accumulator[key] = value - 1;
            }
            return accumulator;
        }, {});
    }
    return table;
}
exports.parseTable = parseTable;
//# sourceMappingURL=index.js.map